{
  "hash": "f9487c28b26c877dbd6fbd235d913619",
  "result": {
    "markdown": "---\ntitle: \"Databser i R\"\nauthor: \"Filip Wästberg\"\ndate: \"2020-08-17\"\ncategories: [databases, sql]\nimage: preview.png\n---\n\n\nAtt jobba med databaser är en av de viktigaste uppgifterna en analytiker eller data scientist har. En tillräckligt stor organisation kan ha flera databaser med olika information och ibland med samma (om än inte alltid överensstämmande). Många  databaser som är skräddarsydda för en organisation har egna User Interface (UI) av varierande kvalitet. Det här leder ibland till att analytiker och data scientists lägger ner mycket tid på att hoppa mellan olika UI:s för olika databaser. Det sägs ibland att en Data Scientist arbetar till 80% med databearbetning, men om personen i fråga spenderar dagarna att navigera olika databaser och deras UI:s är den siffran säkert högre. \n\nAtt nå och effektivit kunna kommunicera med databaser från ett och samma verktyg kan spara en Data Scientist mycket tid. \n\n## Databaser i R\n\nDet finns flera sätt att göra det här på, men jag kommer att argumentera för att göra det i R och IDE:n RStudio. \n\nR har gjort en osannolik resa från att vara ett ganska nischat programmeringsspråk för statistiker till att bli ett av det mest populära verktygen att göra dataanalys i. Ett viktigt skäl till R:s framgång är paketet `dplyr`. `dplyr` används för att göra datamanipulering och bearbetning enklare, med ett starkt fokus på läsbarhet och användarvänlighet. Det har ett intuitivt syntax som i princip vem som helst kan förstå.\n\nFör att visa hur enkelt `dplyr`:s syntax är kan vi utgå från data om irisblomman. Nedan filterar vi först bort arten \"setosa\" och räknar sedan ut den genomsnittliga bladlängden per art. I princip vem som helst kan förstå ungefär vad som pågår nedan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\niris %>% \n  filter(Species != \"setosa\") %>% \n  group_by(Species) %>% \n  summarise(mean_sepal_length = mean(Sepal.Length))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  Species    mean_sepal_length\n  <fct>                  <dbl>\n1 versicolor              5.94\n2 virginica               6.59\n```\n:::\n:::\n\n\nVad har det här med databaser att göra? Eftersom data i arbetslivet ofta ligger i databaser har utvecklarna bakom `dplyr` lagt ner mycket tid på att skriva SQL-översättningar från `dplyr` till olika databaser. Vad det här innebär i praktiken är att du kan använda `dplyr`-syntax för att göra komputeringar i en databas. \n\nLåt oss göra exakt det här genom att skapa en exempeldatabas. Generellt behöver vi användarnamn, lösenord och serverspecifikation för att ansluta till en databas. Men principerna är desamma oavsett om vi skapar den tillfälligt på datorn eller om det är en livs levande databas. För att arbeta med databaser i R laddar vi också paketen `DBI` och `dbplyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(dbplyr)\n\ncon <- dbConnect(RSQLite::SQLite(), \":memory:\")\n\ndbWriteTable(con, \"iris\", iris)\n\niris_tbl <- tbl(con, \"iris\")\n```\n:::\n\n\nObjektet `iris_tbl` är nu en koppling till tabellen `iris` i databasen `con`. Vi kan också titta igenom våra databasobjekt under `Connections` i RStudio. \n\n![](/blog/2020-08-17-demokratisera-databaser-med-r_files/connections2.png)\n\nNär vi nu har en databas kan vi använda `dplyr` för att bearbeta data i databasen. \n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_tbl %>% \n  group_by(Species) %>% \n  summarise(mean_sepal_length = mean(Sepal.Length))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Missing values are always removed in SQL.\nUse `mean(x, na.rm = TRUE)` to silence this warning\nThis warning is displayed only once per session.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   lazy query [?? x 2]\n# Database: sqlite 3.39.3 [:memory:]\n  Species    mean_sepal_length\n  <chr>                  <dbl>\n1 setosa                  5.01\n2 versicolor              5.94\n3 virginica               6.59\n```\n:::\n:::\n\n\nOvan kod exekveras alltså inte i R, som generellt körs lokalt på en server eller en dator, utan på den server där databasen ligger. I bakgrunden översätter `dplyr` koden till `SQL`. Vi kan se hur den översatta queryn ser ut genom `show_query()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_tbl %>% \n  group_by(Species) %>% \n  summarise(mean_sepal_length = mean(Sepal.Length)) %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT `Species`, AVG(`Sepal.Length`) AS `mean_sepal_length`\nFROM `iris`\nGROUP BY `Species`\n```\n:::\n:::\n\n\nPoängen är att vi kan använda R för att exekvera databearbetningar på mycket större datamängder i en databas än vad som är möjligt direkt i R.\n\nNär vi är klara med, säg en aggregering, kan vi enkelt ta in resultatet till R och modellera eller visualisera resultatet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\niris_tbl %>% \n  group_by(Species) %>% \n  summarise(mean_sepal_length = mean(Sepal.Length)) %>% \n  collect() %>% \n  ggplot() +\n  aes(y = Species, x = mean_sepal_length, fill = Species) +\n  geom_col() +\n  theme(legend.position = \"none\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](databaser-i-r_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Vad innebär det här för en analytiker?\n\nDet här gör att vi som analytiker kan arbeta sömlöst med databaser direkt i R. Vi slipper hoppa mellan olika UI:s för alla de databaser som finns i vår organisation. Vi kan aggregera och manipulera data via databasen och sedan lyfta in det i R för att där skapa statistiska modeller och AI-flöden och på så sätt demokratisera \n\nFör en analytiker är själva databearbetningen bara ett steg i analysen och om man kan flytta databearbetningen närmare ett analytiskt verktyg, som R, kan man dels spara tid men framför allt bygga mer robusta flöden. \n\n/ Filip\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "databaser-i-r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}